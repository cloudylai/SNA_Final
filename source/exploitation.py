import sys
import networkx as nx
from math import log


def getUserId(userL):
	max_user = -1;
	temp_list = []
	with open('Gowalla_new/link_prediction/users_info_new.dat', 'r') as f:
		for line in f:
			user = int(line.strip().split()[0])
			if user > max_user:
				max_user = user
			temp_list.append(user)
	print('max user id:', max_user)
	if userL != None:
		userL.extend(temp_list)
	return max_user


def getSpotId(spotL):
	max_spot = -1;
	temp_list = []
	with open('Gowalla_new/link_prediction/spots_info.dat', 'r') as f:
		for line in f:
			spot = int(line.strip().split()[0])
			if spot > max_spot:
				max_spot = spot
			temp_list.append(spot)
	print('max spot id:', max_spot)
	if spotL != None:
		spotL.extend(temp_list)
	return max_spot




def mkUserGraph(G):
	with open('Gowalla_new/link_prediction/users_info_new.dat', 'r') as f:
		for line in f:
			user = int(line.strip().split()[0])
			G.add_node(user)
	with open('Gowalla_new/link_prediction/gowalla.train.txt', 'r') as f:
		for line in f:
			u1, u2, y = line.strip().split()
			u1 = int(u1)
			u2 = int(u2)
			y = int(y)
			if y == 1:
				G.add_edge(u1, u2)



# check dict: {user:{locations}}
# 'C': count each check-in spot; 'DL','LT':record the time(date:hour) of checkin
# 'C': {user:{location:count}}; 'LT': {user:{location:[Date]}}; 'DL': {user:{Date:[location]}}
def getCheckin(checkD, opt):
	with open('Gowalla_new/link_prediction/checkins_info.dat', 'r') as f:
		for line in f:
			info = line.strip().split()
			user = int(info[0])
			checkD[user] = dict()
			for check in info[1:]:
				pos = check.split(':')[-1]
				date = check.split('T')[0]
				time = check.split(':')[0]
				pos = int(pos)
				if opt == 'C':
					if pos not in checkD[user]:
						checkD[user][pos] = 0
					checkD[user][pos] += 1
				elif opt == 'LT':
					if pos not in checkD[user]:
						checkD[user][pos] = []
					checkD[user][pos].append(time)
				elif opt == 'DL':
					if date not in checkD[user]:
						checkD[user][date] = []
					checkD[user][date].append(pos)
				elif opt == 'CLT':
					if pos not in checkD[user]:
						checkD[user][pos] = []
						checkD[user][pos].append(0)
						checkD[user][pos].append(list())
					checkD[user][pos][0] += 1
					checkD[user][pos][1].append(time)
				elif opt == 'CDL':
					if date not in checkD[user]:
						checkD[user][date] = []
						checkD[user][date].append(0)
						checkD[user][date].append(list())
					checkD[user][date][0] += 1
					checkD[user][date][1].append(pos)
				else:
					print('unknown getcheckin option')


# spot dict: {spot: 'C':count; 'LL':lat and lng}
def getSpotInfo(spotD, opt):
	mean_count = 0.0
	mean_lat, mean_lng = 0.0, 0.0
	with open('Gowalla_new/link_prediction/spots_info.dat', 'r') as f:
		for line in f:
			info = line.strip().split()
			spot = int(info[0])
			count = int(info[4])
			lat = float(info[6])
			lng = float(info[8])
			mean_count += count
			mean_lat += lat
			mean_lng += lng
			if opt == 'C':
				spotD[spot] = count
			elif opt == 'LL':
				spotD[spot] = (lat, lng)
#				print('Debug: lat:', lat, 'lng:', lng)
			elif opt == 'CLL':
				spotD[spot] = (count, lat, lng)
#				print('Debug: count:', count)
		mean_lat /= len(spotD)
		mean_lng /= len(spotD)
		mean_count /= len(spotD)
		if opt == 'C':
			spotD['mean'] = mean_count
#			print('Debug: mean checkin count:', mean_count)
		elif opt == 'LL':
			spotD['mean'] = (mean_lat, mean_lng)
		elif opt == 'CLL':
			spotD['mean'] = (mean_count, mean_lat, mean_lng)
#			print('Debug: mean checkin count:', mean_count)


# use the geo of check as the geo of user
# some spot ids in check-in data are not in spot info !!!
def mkUserGeo(userGeo):
	check_dict = dict()
	spot_dict = dict()
	getCheckin(check_dict, 'C')
	getSpotInfo(spot_dict, 'LL')
	mean_lat = 0.0
	mean_lng = 0.0
	for u in check_dict:
		avg_lat = 0.0
		avg_lng = 0.0
		for l in check_dict[u]:
			if l in spot_dict:
				avg_lat += spot_dict[l][0]*check_dict[u][l]
				avg_lng += spot_dict[l][1]*check_dict[u][l]
		avg_lat /= sum(check_dict[u].values())
		avg_lng /= sum(check_dict[u].values())
		mean_lat += avg_lat
		mean_lng += avg_lng
		userGeo[u] = (avg_lat, avg_lng)
	mean_lat /= len(check_dict)
	mean_lng /= len(check_dict)
	userGeo['mean'] = (mean_lat, mean_lng)



def mkSpotEnt(spotEnt):
	check_dict = dict()
	spot_dict = dict()
	getCheckin(check_dict, 'C')
	getSpotInfo(spot_dict, 'C')
	mean_ent = 0.0
	for l in spot_dict:
		if l != 'mean':
			total_check = 0
			ent = 0.0
			for u in check_dict:
				if l in check_dict[u]:
					total_check += check_dict[u][l]
			for u in check_dict:
				if l in check_dict[u]:
					prob = check_dict[u][l] / total_check
					ent -= prob*log(prob)
			spotEnt[l] = ent
			mean_ent += ent
	mean_ent /= len(spotEnt)
	spotEnt['mean'] = mean_ent



def exploitation():
	'''
	# show max user id #
	getUserId(None)
	'''
	
	## MF approach ##
	# write check-in pair file #
	check_dict = dict()
	spot_list = list()
	user_list = list()
	test_user = set()
	getCheckin(check_dict, None)
	user_max = getUserId(user_list)
	spot_max = getSpotId(spot_list)
	'''
	with open('check_pair_tr.txt', 'w') as f:
		for u in check_dict:
			for l in check_dict[u]:
				print(u, l, 1, file=f)
			if spot_max not in check_dict[u]:
				print(u, spot_max, 0, file=f)
		if user_max not in check_dict and spot_max not in check_dict[user_max]:
			print(user_max, spot_max, 0, file=f)
	print('training check pair complete')
	'''
	# write MF test file #
	with open('check_pair_te.txt', 'w') as f:
		for u in user_list:
			for l in spot_list:
				if u not in check_dict or l not in check_dict[u]:
						print(u, l, 0, file=f)
	print('testing check pair complete')	

if __name__ == '__main__':
	exploitation()
